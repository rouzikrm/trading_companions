//@version=5
// Copyright (c) 2019-present, Alex Orekhov (everget)
// Chandelier Exit script may be freely distributed under the terms of the GPL-3.0 license.
indicator('VWAP_SWISS_KNIFE', shorttitle='VWAP_SW', overlay=true)
var float prevwap = na
var float vwapsum = na
var float volumesum = na
var float v2sum = na
var string calcGroup = 'Calculation'
length = input.int(title='ATR Period', defval=22, group=calcGroup)
mult = input.float(title='ATR Multiplier', step=0.1, defval=3.0, group=calcGroup)
useClose = input.bool(title='Use Close Price for Extremums', defval=true, group=calcGroup)

var string visualGroup = 'Visuals'
showLabels = input.bool(title='Show Buy/Sell Labels', defval=true, group=visualGroup)
highlightState = input.bool(title='Highlight State', defval=true, group=visualGroup)

var string alertGroup = 'Alerts'
awaitBarConfirmation = input.bool(title="Await Bar Confirmation", defval=true, group=alertGroup)

atr = mult * ta.atr(length)

longStop = (useClose ? ta.highest(close, length) : ta.highest(length)) - atr
longStopPrev = nz(longStop[1], longStop)
longStop := close[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop

shortStop = (useClose ? ta.lowest(close, length) : ta.lowest(length)) + atr
shortStopPrev = nz(shortStop[1], shortStop)
shortStop := close[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop

var int dir = 1
dir := close > shortStopPrev ? 1 : close < longStopPrev ? -1 : dir

var color longColor = color.green
var color shortColor = color.red
var color longFillColor = color.new(color.green, 90)
var color shortFillColor = color.new(color.red, 90)
var color textColor = color.new(color.white, 0)

longStopPlot = plot(dir == 1 ? longStop : na, title='Long Stop', style=plot.style_linebr, linewidth=2, color=color.new(longColor, 0))
buySignal = dir == 1 and dir[1] == -1
//plotshape(buySignal ? longStop : na, title='Long Stop Start', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(longColor, 0))
plotshape(buySignal and showLabels ? longStop : na, title='Buy Label', text='Buy', location=location.absolute, style=shape.labelup, size=size.tiny, color=color.new(longColor, 0), textcolor=textColor)

shortStopPlot = plot(dir == 1 ? na : shortStop, title='Short Stop', style=plot.style_linebr, linewidth=2, color=color.new(shortColor, 0))
sellSignal = dir == -1 and dir[1] == 1
//plotshape(sellSignal ? shortStop : na, title='Short Stop Start', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(shortColor, 0))
plotshape(sellSignal and showLabels ? shortStop : na, title='Sell Label', text='Sell', location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.new(shortColor, 0), textcolor=textColor)

midPricePlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0, display=display.none, editable=false)

longStateFillColor = highlightState ? dir == 1 ? longFillColor : na : na
shortStateFillColor = highlightState ? dir == -1 ? shortFillColor : na : na
fill(midPricePlot, longStopPlot, title='Long State Filling', color=longStateFillColor)
fill(midPricePlot, shortStopPlot, title='Short State Filling', color=shortStateFillColor)

await = awaitBarConfirmation ? barstate.isconfirmed : true
alertcondition(dir != dir[1] and await, title='Alert: CE Direction Change', message='Chandelier Exit has changed direction!')
alertcondition(buySignal and await, title='Alert: CE Buy', message='Chandelier Exit Buy!')
alertcondition(sellSignal and await, title='Alert: CE Sell', message='Chandelier Exit Sell!')

zsmalength = input.int(title="Length",  defval=32,group="zsma")
zsmaoffset = input.int(title="Offset",  defval=0,group="zsma")
src = input(close, title="Source",group="zsma")
lsma = ta.linreg(src, zsmalength, zsmaoffset)
lsma2 = ta.linreg(lsma, zsmalength, zsmaoffset)
eq= lsma-lsma2
zlsma = lsma+eq

plot(zlsma, color=color.yellow, linewidth=3)

//FUNCTIONS
RoundUp(number, decimals) =>
    factor = math.pow(10, decimals)
    math.ceil(number * factor) / factor
calc_rr(float entry_price, float sl_price, float take_price) => 
    entry_price > sl_price ? (take_price - entry_price) / (entry_price - sl_price) : (entry_price - take_price) / (sl_price - entry_price)

create_trend_line(float sensitivity, float fib) =>
    high_line = ta.highest(high, int(sensitivity))
	low_line = ta.lowest(low, int(sensitivity))
	channel_range = high_line - low_line
	high_line - channel_range * fib
//FUNCTIONS
// TYPES AND METHODS
type Strategy_settings
	float sensitivity = 0
	float risk_percent = 1
	string break_even_target = "1"
	float tp1_percent = 0
	float tp1_percent_fix = 0
	float tp2_percent = 0
	float tp2_percent_fix = 0
	float tp3_percent = 0
	float tp3_percent_fix = 0
	float tp4_percent = 0
	float tp4_percent_fix = 0
	bool fixed_stop = false
	float sl_percent = 0

type Trade
    int start_bar_index = 0
    string side
    float market_order_comission
    float limit_order_comission
    float entry_price
    bool entry_hit = false
    float sl_price
    float tp1_price
	float tp1_percent_fix
    float tp2_price
	float tp2_percent_fix
    float tp3_price
	float tp3_percent_fix
    float tp4_price
	float tp4_percent_fix
    float break_even_price
    bool sl_hit = false
    bool tp1_hit = false
    bool tp2_hit = false
    bool tp3_hit = false
    bool tp4_hit = false
    float position_size_left = 100
	float risk_percent
    bool is_closed = false
    float close_price = 0
    bool can_break_even = false
    bool force_closed = false
    float profit = 0
    float risk_reward
    line entry_line
    line stoploss_line
    line target1_line
    line target2_line
    line target3_line
    line target4_line

method calc_profit(Trade trade, bool show_labels) =>
    label trade_info_label = na
    label entry_hit_label = na
	label tp1_hit_label = na
	label tp2_hit_label = na
	label tp3_hit_label = na
	label tp4_hit_label = na
	label sl_hit_label = na
	label be_hit_label = na
	float profit = 0.0
	if trade.side == "LONG"
        if low <= trade.entry_price and not trade.entry_hit
            trade.start_bar_index := bar_index
            trade.entry_hit := true
            entry_hit_label := label.new(trade.start_bar_index, trade.entry_price, str.tostring("ENTRY HIT"), style = label.style_label_right)
            trade_info_label := label.new(bar_index, high, "Trade info:" + "\nEntry: " + str.tostring(trade.entry_price) + "\nTp1: " + str.tostring(trade.tp1_price) + "\nTp2: " + str.tostring(trade.tp2_price) + "\nTp3:" +  str.tostring(trade.tp3_price) + "\nTp4: " + str.tostring(trade.tp4_price) + "\nSl: " + str.tostring(trade.sl_price))
        if high >= trade.tp1_price and not trade.tp1_hit and trade.entry_hit
            trade.tp1_hit := true
            trade.position_size_left -= trade.tp1_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp1_price) * trade.tp1_percent_fix / 100 * trade.risk_percent
            tp1_hit_label := label.new(trade.start_bar_index, trade.tp1_price, str.tostring("TP1 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if high >= trade.tp2_price and not trade.tp2_hit and trade.entry_hit
            trade.tp2_hit := true
            trade.can_break_even := true
            trade.position_size_left -= trade.tp2_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp2_price) * trade.tp2_percent_fix / 100 * trade.risk_percent
            tp2_hit_label := label.new(trade.start_bar_index, trade.tp2_price, str.tostring("TP2 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if high >= trade.tp3_price and not trade.tp3_hit and trade.entry_hit
            trade.tp3_hit := true
            trade.position_size_left -= trade.tp3_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp3_price) * trade.tp3_percent_fix / 100 * trade.risk_percent
            tp3_hit_label := label.new(trade.start_bar_index, trade.tp3_price, str.tostring("TP3 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if high >= trade.tp4_price and not trade.tp4_hit and trade.entry_hit
            trade.tp4_hit := true
            trade.is_closed := true
            trade.position_size_left -= trade.tp4_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp4_price) * trade.tp4_percent_fix / 100 * trade.risk_percent
            tp4_hit_label := label.new(trade.start_bar_index, trade.tp4_price, str.tostring("TP4 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if high >= trade.break_even_price and not trade.can_break_even and trade.entry_hit
            trade.can_break_even := true
        //BE ENTRY HIT
        if trade.can_break_even and trade.entry_hit
            if low <= trade.entry_price and not (close >= open) and bar_index != trade.start_bar_index
                trade.is_closed := true
                be_hit_label := label.new(bar_index, trade.entry_price, str.tostring("BE HIT"), style = label.style_label_left)
        // SL HIT
        if low <= trade.sl_price and not trade.can_break_even and trade.entry_hit and bar_index != trade.start_bar_index
            trade.sl_hit := true
            trade.is_closed := true
            profit += -trade.risk_percent * trade.position_size_left / 100
            sl_hit_label := label.new(bar_index, trade.sl_price, str.tostring("SL HIT ") + str.tostring(profit, "#.##") + "%", color = color.red, style = label.style_label_left)
    else
        if high >= trade.entry_price and not trade.entry_hit
            trade.start_bar_index := bar_index
            trade.entry_hit := true
            entry_hit_label := label.new(trade.start_bar_index, trade.entry_price, str.tostring("ENTRY HIT"), style = label.style_label_right)
            trade_info_label := label.new(bar_index, high, "Trade info:" + "\nEntry: " + str.tostring(trade.entry_price) + "\nTp1: " + str.tostring(trade.tp1_price) + "\nTp2: " + str.tostring(trade.tp2_price) + "\nTp3:" +  str.tostring(trade.tp3_price) + "\nTp4: " + str.tostring(trade.tp4_price) + "\nSl: " + str.tostring(trade.sl_price))
        if low <= trade.tp1_price and not trade.tp1_hit and trade.entry_hit
            trade.tp1_hit := true
            trade.position_size_left -= trade.tp1_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp1_price) * trade.tp1_percent_fix / 100 * trade.risk_percent
            tp1_hit_label := label.new(trade.start_bar_index, trade.tp1_price, str.tostring("TP1 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if low <= trade.tp2_price and not trade.tp2_hit and trade.entry_hit
            trade.tp2_hit := true
            trade.position_size_left -= trade.tp2_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp2_price) * trade.tp2_percent_fix / 100 * trade.risk_percent
            tp2_hit_label := label.new(trade.start_bar_index, trade.tp2_price, str.tostring("TP2 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if low <= trade.tp3_price and not trade.tp3_hit and trade.entry_hit
            trade.tp3_hit := true
            trade.position_size_left -= trade.tp3_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp3_price) * trade.tp3_percent_fix / 100 * trade.risk_percent
            tp3_hit_label := label.new(trade.start_bar_index, trade.tp3_price, str.tostring("TP3 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if low <= trade.tp4_price and not trade.tp4_hit and trade.entry_hit
            trade.tp4_hit := true
            trade.is_closed := true
            trade.position_size_left -= trade.tp4_percent_fix
            profit += calc_rr(trade.entry_price, trade.sl_price, trade.tp4_price) * trade.tp4_percent_fix / 100  * trade.risk_percent
            tp4_hit_label := label.new(trade.start_bar_index, trade.tp4_price, str.tostring("TP4 HIT +") + str.tostring(profit, "#.##") + "%" + "\nPosition size %: " + str.tostring(trade.position_size_left), style = label.style_label_right)
        if low <= trade.break_even_price and not trade.can_break_even and trade.entry_hit
            trade.can_break_even := true
        //BE ENTRY HIT
        if trade.can_break_even and trade.entry_hit
            if high >= trade.entry_price and not (close <= open) and bar_index != trade.start_bar_index
                trade.is_closed := true
                be_hit_label := label.new(bar_index, trade.entry_price, str.tostring("BE HIT"), style = label.style_label_left)
        // SL HIT
        if high >= trade.sl_price and not trade.can_break_even and trade.entry_hit and bar_index != trade.start_bar_index
            trade.sl_hit := true
            trade.is_closed := true
            profit += -trade.risk_percent * trade.position_size_left / 100
            sl_hit_label := label.new(bar_index, trade.sl_price, str.tostring("SL HIT ") + str.tostring(profit, "#.##") + "%", color = color.red, style = label.style_label_left)
    trade.profit += profit
	if not show_labels
        label.delete(entry_hit_label)
		label.delete(tp1_hit_label)
		label.delete(tp2_hit_label)
		label.delete(tp3_hit_label)
		label.delete(tp4_hit_label)
		label.delete(sl_hit_label)
		label.delete(be_hit_label)
        label.delete(trade_info_label)

method close_trade(Trade trade, bool show_labels) =>
    float profit = 0.0
    label trade_closed_label = na
    trade.force_closed := true
    if not trade.sl_hit
        if trade.side == "SHORT"
            trade.is_closed := true
            trade.close_price := close
            if close <= trade.entry_price
                percent_from_entry_to_close_price_at_trend_change =  math.abs((close / trade.entry_price) * 100)
                percent_from_entry_to_sl_price = math.abs((trade.entry_price / trade.sl_price) * 100)
                profit := calc_rr(trade.entry_price, trade.sl_price, close) * trade.position_size_left / 100 * trade.risk_percent
            else
                profit := calc_rr(trade.entry_price, trade.sl_price, close) * trade.position_size_left / 100 * trade.risk_percent
            string sign = profit >= 0 ? "+" : na
            trade_closed_label := label.new(bar_index, high, str.tostring("TRADE CLOSED ") + sign + str.tostring(profit, "#.##") + "%")
        else
            trade.is_closed := true
            trade.close_price := close
            if close <= trade.entry_price
                percent_from_entry_to_close_price_at_trend_change =  math.abs((close / trade.entry_price - 1) * 100)
                percent_from_entry_to_sl_price = math.abs((trade.entry_price / trade.sl_price - 1) * 100)
                profit := -trade.risk_percent * (percent_from_entry_to_close_price_at_trend_change / percent_from_entry_to_sl_price) * trade.position_size_left / 100 + trade.profit
            else
                profit := calc_rr(trade.entry_price, trade.sl_price, close) * trade.position_size_left / 100 * trade.risk_percent
            string sign = profit >= 0 ? "+" : na
            trade_closed_label := label.new(bar_index, low, str.tostring("TRADE CLOSED ") + sign + str.tostring(profit, "#.##") + "%", style = label.style_label_up)
    if not show_labels
        label.delete(trade_closed_label)
    trade.profit += profit
// TYPES AND METHODS

// STRATS
selector(string strategy_name) =>
	strategy_settings = Strategy_settings.new()
	switch strategy_name
		"MANUAL" =>
			strategy_settings.sensitivity := 18
			strategy_settings.risk_percent := 1
			strategy_settings.break_even_target := "1"
			strategy_settings.tp1_percent := 1
			strategy_settings.tp1_percent_fix := 40
			strategy_settings.tp2_percent := 2
			strategy_settings.tp2_percent_fix := 30
			strategy_settings.tp3_percent := 3
			strategy_settings.tp3_percent_fix := 20
			strategy_settings.tp4_percent := 4
			strategy_settings.tp4_percent_fix := 10
			strategy_settings.fixed_stop := false
			strategy_settings.sl_percent := 0.0
		"UNIVERSAL 15m" => 
			strategy_settings.sensitivity := 20
			strategy_settings.risk_percent := 1
			strategy_settings.break_even_target := "1"
			strategy_settings.tp1_percent := 1
			strategy_settings.tp1_percent_fix := 40
			strategy_settings.tp2_percent := 2
			strategy_settings.tp2_percent_fix := 30
			strategy_settings.tp3_percent := 3
			strategy_settings.tp3_percent_fix := 20
			strategy_settings.tp4_percent := 4
			strategy_settings.tp4_percent_fix := 10
			strategy_settings.fixed_stop := false
			strategy_settings.sl_percent := 0.0
		"SOL 5m" => 
			strategy_settings.sensitivity := 20
			strategy_settings.risk_percent := 1
			strategy_settings.break_even_target := "1"
			strategy_settings.tp1_percent := 1
			strategy_settings.tp1_percent_fix := 40
			strategy_settings.tp2_percent := 2
			strategy_settings.tp2_percent_fix := 30
			strategy_settings.tp3_percent := 3
			strategy_settings.tp3_percent_fix := 20
			strategy_settings.tp4_percent := 4
			strategy_settings.tp4_percent_fix := 10
			strategy_settings.fixed_stop := false
			strategy_settings.sl_percent := 0.0
	strategy_settings
// STRATS

string STRATEGIES = "STRATEGIES"
string POSITION = "POSITION"
string ENTRY = "ENTRY"
string TAKE_PROFITS = "TAKE PROFITS"
string STOP_LOSS = "STOPLOSS"
string rsi_group = "RSI"
string main_group = "MAIN"
string info_panel_group = "INFOPANELS"
string dev_settings = "DEVELOPER MODE"

int fibo_lines_transparend = 60
int fill_best_transparend = 95
int fill_worst_transparend = 98

color high_line_color = color.rgb(36, 255, 44, fibo_lines_transparend)
color fib_236_color = color.rgb(130, 228, 74, fibo_lines_transparend)
color fib_382_color = color.rgb(171, 224, 174, fibo_lines_transparend)
color fib_618_color = color.rgb(235, 255, 51, fibo_lines_transparend)
color fib_786_color = color.rgb(255, 131, 73, fibo_lines_transparend)
color low_line_color = color.rgb(255, 82, 82, fibo_lines_transparend)

color high_best_fill_color = color.rgb(48, 255, 55, fill_best_transparend)
color high_worst_fill_color = color.rgb(37, 255, 44, fill_worst_transparend)
color low_best_fill_color = color.rgb(255, 54, 54, fill_best_transparend)
color low_worst_fill_color = color.rgb(255, 43, 43, fill_worst_transparend)

tp_sl_entry_transparent = 30
color tp_color = color.new(color.green, tp_sl_entry_transparent)
color entry_color = color.rgb(120, 123, 134, tp_sl_entry_transparent)
color sl_color = color.new(color.red, tp_sl_entry_transparent)
line_style = line.style_dotted


//@version=5
//indicator(title='[IMBA] ALGO', shorttitle='[IMBA] ALGO', overlay=true, max_lines_count = 500, max_labels_count = 500, max_bars_back = 1)

//---------------------------------------------------SETTINGS----------------------------------------------------------\\
// STRATS
var float sensitivity = 18
float risk_percent = 1
string break_even_target = "2"
float tp1_percent = 0
float tp1_percent_fix = 0
float tp2_percent = 0
float tp2_percent_fix = 0
float tp3_percent = 0
float tp3_percent_fix = 0
float tp4_percent = 0
float tp4_percent_fix = 0
bool fixed_stop = false
float sl_percent = 0

strategy_input = input.string(title = "STRATEGY", options = [
     "MANUAL",
     "UNIVERSAL 15m",
     "===============",
     "-------A-------",
     "-------B-------",
     "-------C-------",
     "-------D-------",
     "-------E-------",
     "-------F-------",
     "-------G-------",
     "-------H-------",
     "-------I-------",
     "-------J-------",
     "-------K-------",
     "-------L-------",
     "-------M-------",
     "-------N-------",
     "-------O-------",
     "-------P-------",
     "-------Q-------",
     "-------R-------",
     "-------S-------",
     "SOL 5m",
     "-------T-------",
     "-------U-------",
     "-------V-------",
     "-------W-------",
     "-------X-------",
     "-------Y-------",
     "-------Z-------"
     ], defval = "MANUAL", tooltip = "EN:\nTo manually configure the strategy, select MANUAL otherwise, changing the settings won't have any effect\nRU:\nЧтобы настроить стратегию вручную, выберите MANUAL в противном случае изменение настроек не будет иметь никакого эффекта")

// MAIN
sensitivity_input = input.float(title = 'Sensitive', step = 0.1, defval = 18)
start_date_input = input.time(defval = timestamp("1 June 2023"), title = "Start calculating date")
// POSITION
show_tp_enty_sl = input.bool(defval = true, title = "Show", group = POSITION, inline = "2.1")
fill_positions = input.bool(defval = true, title = "Fill", group = POSITION, inline = "2.1")
risk_percent_input = input.float(title = "Risk %", step = 1, defval = 1, group = POSITION, tooltip = "EN:\nMaximum allowable loss % of the deposit per 1 trade\nRU:\nМаксимально допустимая потеря % от депозита на 1 сделку")
break_even_target_input = input.string(title = "BE target", options = ["WITHOUT","1","2","3"], defval = "1", group = POSITION)
initial_deposit_input = input.float(title = "Initial deposit", defval = 1000, step = 100, group = POSITION)
// STOPLOSS
fixed_stop_input = input.bool(defval = false, title = "Fixed stoploss %", group = STOP_LOSS, tooltip = "EN:\nIf choosed: stoploss will be calculated manually \nIf NOT choosed: stoploss will be calculated automatic\nRU:\nЕсли выбрано: стоп будет рассчитываться вручную \nЕсли НЕ выбрано: стоп будет рассчитываться автоматически")
sl_percent_input = input.float(title="SL %", step = 0.1, defval=0.00, group = STOP_LOSS)
// TAKE PROFITS
tp1_percent_input = input.float(title="TP 1", step = 0.05, defval=1.00, minval = 0, group = TAKE_PROFITS, inline = "2.2")
tp1_percent_fix_input = input.float(title = "Fix %", step = 5, defval=40, group = TAKE_PROFITS, inline = "2.2")
tp2_percent_input = input.float(title="TP 2", step = 0.05, defval=2.00, minval = 0, group = TAKE_PROFITS, inline = "2.3")
tp2_percent_fix_input = input.float(title = "Fix %", step = 5, defval=30, group = TAKE_PROFITS, inline = "2.3")
tp3_percent_input = input.float(title="TP 3", step = 0.05, defval=3.00, minval = 0, group = TAKE_PROFITS, inline = "2.4")
tp3_percent_fix_input = input.float(title = "Fix %", step = 5, defval=20, group = TAKE_PROFITS, inline = "2.4")
tp4_percent_input = input.float(title="TP 4", step = 0.05, defval=4.00, minval = 0, group = TAKE_PROFITS, inline = "2.5")
tp4_percent_fix_input = input.float(title = "Fix %", step = 5, defval=10, group = TAKE_PROFITS, inline = "2.5")

// RSI
show_rsi = input.bool(defval = false, title = "Show", group = rsi_group, inline = "3.1")
len = input(title="Length", defval=14, group = rsi_group, inline = "3.2")
overbought = input(title="Overbought", defval=78, group = rsi_group, inline = "3.3")
oversold = input(title="Oversold", defval=22, group = rsi_group, inline = "3.3")
// INFO PANEL
show_profit_panel = input.bool(defval = true, title = "Show profit panel", group = info_panel_group)
show_strategy_panel = input.bool(defval = false, title = "Show strategy panel", group = info_panel_group)
show_old_panel = input.bool(defval = false, title = "Show old panel", group = info_panel_group)
// DEV
show_dev_labels = input.bool(defval = false, title = "Show", group = dev_settings, tooltip = "Shows all possible events")

//-----------------------------------------------GLOBAL VARIABLES------------------------------------------------------\\
var float total_profit = 0.0
var int trade_count = 0
var int profit_trades = 0
var int loss_trades = 0
var int loss_streak = 0
var int loss_in_a_row = 0
var int win_streak = 0
var int wins_in_a_row = 0
var int first_trade_date = na
var Trade trade = na
var bool is_long_trend_started = false
var bool is_short_trend_started = false
var bool is_trend_change = na
var bool is_long_trend = false
var bool is_short_trend = false
var bool can_long = false
var bool can_short = false

var int trend_started_bar_index = na
var line tp1_line = na
var label tp1_label = na
var line tp2_line = na
var label tp2_label = na
var line tp3_line = na
var label tp3_label = na
var line tp4_line = na
var label tp4_label = na
var line entry_line = na
var label entry_label = na
var line close_line = na
var line sl_line = na
var label sl_label = na
var label lable_at_signal = na
var int signal_closed_bar = na
var Strategy_settings strategy_s = na
var float dep = initial_deposit_input
//-----------------------------------------------------MAIN------------------------------------------------------------\\
// STRATEGY

strategy_s := strategy_input == "MANUAL" ? Strategy_settings.new(sensitivity_input, risk_percent_input, break_even_target_input, tp1_percent_input, tp1_percent_fix_input, tp2_percent_input, tp2_percent_fix_input, tp3_percent_input, tp3_percent_fix_input, tp4_percent_input, tp4_percent_fix_input, fixed_stop_input, sl_percent_input) : selector(strategy_input)

sensitivity := strategy_s.sensitivity
risk_percent := strategy_s.risk_percent
break_even_target := strategy_s.break_even_target
tp1_percent := strategy_s.tp1_percent
tp1_percent_fix := strategy_s.tp1_percent_fix
tp2_percent := strategy_s.tp2_percent
tp2_percent_fix := strategy_s.tp2_percent_fix
tp3_percent := strategy_s.tp3_percent
tp3_percent_fix := strategy_s.tp3_percent_fix
tp4_percent := strategy_s.tp4_percent
tp4_percent_fix := strategy_s.tp4_percent_fix
fixed_stop := strategy_s.fixed_stop
sl_percent := strategy_s.sl_percent

sensitivity *= 10
tp1_percent /= 100
tp2_percent /= 100
tp3_percent /= 100
tp4_percent /= 100
tp1_percent_fix /= 100
tp2_percent_fix /= 100
tp3_percent_fix /= 100
tp4_percent_fix /= 100
sl_percent /= 100


high_line = ta.highest(high, int(sensitivity))
low_line = ta.lowest(low, int(sensitivity))
channel_range = high_line - low_line
fib_236 = high_line - channel_range * (0.236)
fib_382 = high_line - channel_range * 0.382
fib_5 = high_line - channel_range * 0.5
fib_618 = high_line - channel_range * 0.618
fib_786 = high_line - channel_range * (0.786)
imba_trend_line = fib_5

// CAN LONG/SHORT
if time >= start_date_input
    can_long := close >= imba_trend_line and close >= fib_236 and not is_long_trend
    can_short := close <= imba_trend_line and close <= fib_786 and not is_short_trend

if can_long
    is_long_trend := true
    is_short_trend := false
    is_long_trend_started := is_long_trend_started ? false : true
else if can_short
    is_short_trend := true
    is_long_trend := false
    is_short_trend_started := is_short_trend_started ? false : true
else
    is_trend_change := false
    can_long := false
    can_short := false
    is_short_trend_started := false
    is_long_trend_started := false

is_trend_change := is_short_trend_started or is_long_trend_started
//lotshape(is_long_trend and is_long_trend_started ? imba_trend_line : na, title="Long", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small)
//plotshape(is_short_trend and is_short_trend_started ? imba_trend_line : na, title="Short", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small)
//plot(imba_trend_line, color = is_long_trend[1] ? color.green : color.red, linewidth = 3)

// LOGIC
if not na(trade)
    calc_profit(trade, show_dev_labels)
    if is_trend_change and not trade.is_closed
        close_trade(trade, show_dev_labels)
    if not trade.is_closed
        label.set_x(entry_label, bar_index - 3)
        label.set_text(entry_label, str.tostring(trade.side == "LONG" ? "🔰" : "🔰")  + str.tostring(trade.entry_price))
        label.set_x(sl_label, bar_index - 3)
        label.set_text(sl_label, "⛔" + str.tostring(trade.sl_price))
        label.set_x(tp1_label, bar_index - 3)
        label.set_text(tp1_label, str.tostring(trade.tp1_hit ? "✅" : "1️⃣") + str.tostring(trade.tp1_price))
        label.set_x(tp2_label, bar_index - 3)
        label.set_text(tp2_label, str.tostring(trade.tp2_hit ? "✅" : "2️⃣") + str.tostring(trade.tp2_price))
        label.set_x(tp3_label, bar_index - 3)
        label.set_text(tp3_label, str.tostring(trade.tp3_hit ? "✅" : "3️⃣") + str.tostring(trade.tp3_price))
        label.set_x(tp4_label, bar_index - 3)
        label.set_text(tp4_label, str.tostring(trade.tp4_hit ? "✅" : "4️⃣") + str.tostring(trade.tp4_price))
        line.set_xy1(tp1_line, trade.start_bar_index, trade.tp1_price)
        line.set_xy2(tp1_line, bar_index + 1, trade.tp1_price)
        line.set_xy1(tp2_line, trade.start_bar_index, trade.tp2_price)
        line.set_xy2(tp2_line, bar_index + 1, trade.tp2_price)
        line.set_xy1(tp3_line, trade.start_bar_index, trade.tp3_price)
        line.set_xy2(tp3_line, bar_index + 1, trade.tp3_price)
        line.set_xy1(tp4_line, trade.start_bar_index, trade.tp4_price)
        line.set_xy2(tp4_line, bar_index + 1, trade.tp4_price)
        line.set_xy1(entry_line, trade.start_bar_index, trade.entry_price)
        line.set_xy2(entry_line, bar_index + 1, trade.entry_price)
        line.set_xy1(sl_line, trade.start_bar_index, trade.sl_price)
        line.set_xy2(sl_line, bar_index + 1, trade.sl_price)
        
    lable_at_signal.set_x(int(math.avg(bar_index, trade.start_bar_index)))
    sign = trade.profit >= 0 ? "+" : na
    lable_at_signal.set_text(sign + str.tostring(trade.profit, "#.##") + "%")
    lable_at_signal.set_color(trade.profit >= 0 ? color.green : color.red)

    // FILLING
    if fill_positions
        if trade.tp1_hit
            linefill.new(entry_line, tp1_line, color = color.new(color.green, 85))
        if trade.tp2_hit
            linefill.new(tp1_line, tp2_line, color = color.new(color.green, 85))
        if trade.tp3_hit
            linefill.new(tp2_line, tp3_line, color = color.new(color.green, 85))
        if trade.tp4_hit
            linefill.new(tp3_line, tp4_line, color = color.new(color.green, 85))
        if trade.sl_hit
            linefill.new(sl_line, entry_line, color = color.new(color.red, 85))
        if trade.force_closed
            close_line := line.new(x1=trade.start_bar_index, y1=trade.close_price, x2=bar_index, y2=trade.close_price, color=color.white, style = line_style, width = 2)
            if trade.profit <= 0
                linefill.new(close_line, entry_line, color = color.new(color.red, 85))

    if trade.is_closed
        dep := (trade.profit / 100 * dep) + dep
        label.delete(entry_label)
        label.delete(sl_label)
        label.delete(tp1_label)
        label.delete(tp2_label)
        label.delete(tp3_label)
        label.delete(tp4_label)
        total_profit += trade.profit
        trade_count += 1
        if trade.profit >= 0
            profit_trades += 1
            wins_in_a_row += 1
            loss_in_a_row := 0
            win_streak := wins_in_a_row > win_streak ? wins_in_a_row : win_streak
        else
            loss_trades += 1
            loss_in_a_row += 1
            wins_in_a_row := 0
            loss_streak := loss_in_a_row > loss_streak ? loss_in_a_row : loss_streak
        trade := na

alertcondition(can_long and na(trade), "Long signal", "Long")
alertcondition(can_short and na(trade), "Short signal", "Short")
alertcondition(can_short or can_long and na(trade), "New signal", "Check chart to see signal direction")
if can_long or can_short and na(trade)
    first_trade_date := trade_count == 0 ? timestamp(year, month, dayofmonth, hour, minute) : first_trade_date
    trade := Trade.new()
    trade.side := can_long ? "LONG" : "SHORT"
    trade.entry_price := close
    trade.entry_hit := true
    trade.sl_price := math.round_to_mintick(can_long ? fixed_stop ? trade.entry_price * (1 - sl_percent) : fib_786 * (1 - sl_percent) : fixed_stop ? trade.entry_price * (1 + sl_percent) : fib_236 * (1 + sl_percent))
    trade.tp1_price := math.round_to_mintick(can_long ? trade.entry_price * (1 + tp1_percent) : trade.entry_price * (1 - tp1_percent))
    trade.tp1_percent_fix := tp1_percent_fix * 100
    trade.tp2_price := math.round_to_mintick(can_long ? trade.entry_price * (1 + tp2_percent) : trade.entry_price * (1 - tp2_percent))
    trade.tp2_percent_fix := tp2_percent_fix * 100
    trade.tp3_price := math.round_to_mintick(can_long ? trade.entry_price * (1 + tp3_percent) : trade.entry_price * (1 - tp3_percent))
    trade.tp3_percent_fix := tp3_percent_fix * 100
    trade.tp4_price := math.round_to_mintick(can_long ? trade.entry_price * (1 + tp4_percent) : trade.entry_price * (1 - tp4_percent))
    trade.tp4_percent_fix := tp4_percent_fix * 100
    trade.break_even_price := switch break_even_target
        "1" => trade.tp1_price
        "2" => trade.tp2_price
        "3" => trade.tp3_price
        "WITHOUT" => trade.tp4_price
    trade.risk_percent := risk_percent
    trade.risk_reward := calc_rr(trade.entry_price, trade.sl_price, trade.tp4_price)
    trade.start_bar_index := bar_index
    alert_message = "\n{\n" +  "    \"side\": \"" + str.tostring(trade.side) + "\",\n    \"entry\": \"" + str.tostring(trade.entry_price) + "\",\n    \"tp1\": \"" + str.tostring(trade.tp1_price) + "\",\n    \"tp2\": \"" + str.tostring(trade.tp2_price) + "\",\n    \"tp3\": \"" + str.tostring(trade.tp3_price) + "\",\n    \"tp4\": \"" + str.tostring(trade.tp4_price) + "\",\n    \"winrate\": \"" + str.tostring(RoundUp(profit_trades / trade_count * 100, 2)) + "%" + "\",\n    \"strategy\": \"" + strategy_input + "\",\n    \"beTargetTrigger\": \"" + break_even_target + "\",\n    \"stop\": \"" + str.tostring(trade.sl_price) + "\"\n}\n"
    alert(alert_message, alert.freq_once_per_bar_close)
    if show_tp_enty_sl
        entry_line  := line.new(x1=trade.start_bar_index, y1=trade.entry_price, x2=bar_index, y2=trade.entry_price, color=entry_color, style = line.style_solid, width = 2)
        entry_label := label.new(bar_index, trade.entry_price, str.tostring(trade.entry_price), style = label.style_label_left, color = color.rgb(255, 255, 255, 100), textcolor = color.gray)
        sl_line     := line.new(x1=trade.start_bar_index, y1=trade.sl_price, x2=bar_index, y2=trade.sl_price, color=sl_color, style = line_style, width = 2)
        sl_label := label.new(bar_index, trade.sl_price, str.tostring(trade.sl_price), style = label.style_label_left, color = color.rgb(255, 255, 255, 100), textcolor = color.red)
        tp1_line    := line.new(x1=trade.start_bar_index, y1=trade.tp1_price, x2=bar_index, y2=trade.tp1_price, color=tp_color, style = line_style, width = 2)
        tp1_label := label.new(bar_index, trade.tp1_price, str.tostring(trade.tp1_price), style = label.style_label_left, color = color.rgb(255, 255, 255, 100), textcolor = color.green)
        tp2_line    := line.new(x1=trade.start_bar_index, y1=trade.tp2_price, x2=bar_index, y2=trade.tp2_price, color=tp_color, style = line_style, width = 2)
        tp2_label := label.new(bar_index, trade.tp2_price, str.tostring(trade.tp2_price), style = label.style_label_left, color = color.rgb(255, 255, 255, 100), textcolor = color.green)
        tp3_line    := line.new(x1=trade.start_bar_index, y1=trade.tp3_price, x2=bar_index, y2=trade.tp3_price, color=tp_color, style = line_style, width = 2)
        tp3_label := label.new(bar_index, trade.tp3_price, str.tostring(trade.tp3_price), style = label.style_label_left, color = color.rgb(255, 255, 255, 100), textcolor = color.green)
        tp4_line    := line.new(x1=trade.start_bar_index, y1=trade.tp4_price, x2=bar_index, y2=trade.tp4_price, color=tp_color, style = line_style, width = 2)
        tp4_label := label.new(bar_index, trade.tp4_price, str.tostring(trade.tp4_price), style = label.style_label_left, color = color.rgb(255, 255, 255, 100), textcolor = color.green)
        lable_at_signal := label.new(bar_index, is_long_trend ? trade.tp4_price * 1.004 : trade.tp4_price * 0.996, "", style = label.style_label_center, textcolor = color.white)
    
//------------------------------------------------------RSI------------------------------------------------------------\\
rsi_value = ta.rsi(close, len)
is_overbought = rsi_value >= overbought
is_oversold = rsi_value <= oversold
//plotshape(is_overbought and show_rsi ? high : na, color=color.red, style=shape.cross, size=size.tiny, location=location.abovebar)
//plotshape(is_oversold and show_rsi ? low : na, color=color.green, style=shape.cross, size=size.tiny, location=location.belowbar)

//-----------------------------------------------------PANELS------------------------------------------------------------\\
lim = "-------------------------------------------------------"
high_idk = "╔════════════════════════════╗"
low_idk = "╚════════════════════════════╝"
panel_str1 = high_idk + "\n" + "[IMBA] ALGO" + "\n" + low_idk
panel_str13 = "First signal: " + str.format("{0,date,hh:mm} {0,date,long}", first_trade_date) + "\n" + lim
panel_str14 = "Signal closed: " + str.tostring(trade_count) + "                 " + "Winrate: " + str.tostring(RoundUp(profit_trades / trade_count * 100, 2)) + "%"
panel_str15 = "Profit signals: " + str.tostring(profit_trades) + "              " + "Loss signals: " + str.tostring(trade_count - profit_trades)
panel_str16 = "Win streak: " + str.tostring(win_streak) + "                  " + "Loss streak: " + str.tostring(loss_streak) + "\n" + lim
panel_str17 = "💰 Profit: " + str.tostring(total_profit, "#.##") + "% 💰"
panel_last = "╚════════════════════════════╝" 
panel_str_arr = array.from(panel_str1, panel_str13, panel_str14, panel_str15, panel_str16, panel_str17, panel_last)
if show_old_panel
    label l = label.new(bar_index + 20, close, text=array.join(panel_str_arr, "\n"), color=color.rgb(0, 0, 0, 87), style=label.style_label_left, textcolor=color.rgb(76, 187, 72),textalign=text.align_center)
    label.delete(l[1])

var table profit_table = na
if show_profit_panel
    profit_table := table.new(position.top_right, 3, 10, border_color = color.green, border_width = 0)
    table.cell(profit_table, 0, 0, "═════════════════════════════" + "\n" + "[IMBA] ALGO" + "\n" + "═════════════════════════════", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 5, text_size = size.normal)
    table.cell(profit_table, 1, 0, "", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 3, text_size = size.normal)
    table.merge_cells(profit_table, 0,0,1,0)
    table.cell(profit_table, 0, 1, "First trade:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 8, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 1, str.format("{0,date,long}", first_trade_date), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 8, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 2, "Total trades:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 2, str.tostring(trade_count), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 3, "Profit trades:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 3, str.tostring(profit_trades), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 4, "Loss trades:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 4, str.tostring(loss_trades), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 5, "Winrate:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 5, str.tostring(RoundUp(profit_trades / trade_count * 100, 2)) + "%", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 6, "Win streak:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 6, str.tostring(win_streak), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 7, "Loss streak:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 7, str.tostring(loss_streak), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 8, "Deposit: ", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(profit_table, 1, 8, str.tostring(dep, "##.##"), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(profit_table, 0, 9, "═════════════════════════════" + "\n" + "💰 Profit: " + str.tostring(total_profit, "#.##") + "% 💰" + "\n" + "═════════════════════════════", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 10, text_size = size.normal, text_halign = text.align_center, text_valign = text.align_top)
    table.cell(profit_table, 1, 9,"", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.merge_cells(profit_table, 0, 9, 1, 9)

var table strategy_table = na
if show_strategy_panel
    strategy_table := table.new(position.bottom_right, 5, 6, border_color = color.green)
    table.cell(strategy_table, 1, 0, "══════════════════════════════════════════" + "\n" + syminfo.ticker + " " + timeframe.period + " | WR: " + str.tostring(profit_trades / (profit_trades + (trade_count - profit_trades)) * 100, "##,##") + "%" + " | TT: " + str.tostring(trade_count) + " | P: " +  str.tostring(total_profit, "#.##") + "%" + "\n" + "══════════════════════════════════════════", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 7, text_size = size.normal, text_valign = text.align_bottom)
    table.cell(strategy_table, 2, 0, "", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 3, text_size = size.normal)
    table.cell(strategy_table, 3, 0, "", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 3, text_size = size.normal)
    table.cell(strategy_table, 4, 0, "", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 3, text_size = size.normal)
    table.merge_cells(strategy_table, 1,0,4,0)
    table.cell(strategy_table, 1, 1, "Strategy:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(strategy_table, 2, 1, strategy_input, bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 6, height = 3, text_size = size.normal)
    table.cell(strategy_table, 1, 2, "Sensitivity:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(strategy_table, 2, 2, str.tostring(sensitivity / 10), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(strategy_table, 1, 3, "Risk:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(strategy_table, 2, 3, str.tostring(risk_percent) + "%", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(strategy_table, 1, 4, "BE target:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(strategy_table, 2, 4, str.tostring(break_even_target), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(strategy_table, 1, 5, "Fixed stop:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal, text_halign = text.align_left)
    table.cell(strategy_table, 2, 5, str.tostring(fixed_stop), bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)

    table.cell(strategy_table, 3, 1, "TP1:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 4, height = 3, text_size = size.normal)
    table.cell(strategy_table, 4, 1, str.tostring(tp1_percent * 100) + "%" + " (" + str.tostring(tp1_percent_fix * 100) + "%)", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(strategy_table, 3, 2, "TP2:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 4, height = 3, text_size = size.normal)
    table.cell(strategy_table, 4, 2, str.tostring(tp2_percent * 100) + "%" + " (" + str.tostring(tp2_percent_fix * 100) + "%)", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(strategy_table, 3, 3, "TP3:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 4, height = 3, text_size = size.normal)
    table.cell(strategy_table, 4, 3, str.tostring(tp3_percent * 100) + "%" + " (" + str.tostring(tp3_percent_fix * 100) + "%)", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(strategy_table, 3, 4, "TP4:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 4, height = 3, text_size = size.normal)
    table.cell(strategy_table, 4, 4, str.tostring(tp4_percent * 100) + "%" + " (" + str.tostring(tp4_percent_fix * 100) + "%)", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 5, height = 3, text_size = size.normal)
    table.cell(strategy_table, 3, 5, "Stop:", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 4, height = 3, text_size = size.normal)
    table.cell(strategy_table, 4, 5, str.tostring(sl_percent * 100) + "%", bgcolor = color.rgb(0, 0, 0, 87), text_color = color.green, width = 8, height = 3, text_size = size.normal)
// Advanced By Trader Hari Krishna
// SSL HYBRID By Mihkel00
// This script is designed for the NNFX Method, so it is recommended for Daily charts only. 
// Tried to implement a few VP NNFX Rules
// This script has a SSL / Baseline (you can choose between the SSL or MA), a secondary SSL for continiuation trades and a third SSL for exit trades.
// Alerts added for Baseline entries, SSL2 continuations, Exits.
// Baseline has a Keltner Channel setting for "in zone" Gray Candles
// Added "Candle Size > 1 ATR" Diamonds from my old script with the criteria of being within Baseline ATR range.
// Credits
// Strategy causecelebre https://www.tradingview.com/u/causecelebre/
// SSL Channel ErwinBeckers https://www.tradingview.com/u/ErwinBeckers/
// Moving Averages jiehonglim https://www.tradingview.com/u/jiehonglim/
// Moving Averages  everget https://www.tradingview.com/u/everget/
// "Many Moving Averages" script  Fractured https://www.tradingview.com/u/Fractured/
// Thanks to Sideways Filter Suggestion by @vicfoug63 and @diLiviu
//indicator('SSL HYBRID ADVANCED', overlay=true)
sslsignals=input.string(title='Buy Sell Signals', defval='SSL-HYBRID', options=['SSL-HYBRID', 'SSL+QQE+WAE','SSL-HYBRID+SuperTrend'], group='Settings: Signals',inline='Filter')
strend=input.string(title='Filter Buy Sell Signals', defval='NO-FILTER', options=['NO-FILTER', 'SUPERTREND','HULL'], group='Settings: Signals',inline='Filter')
squeezesignalfilter= input(false, title='Remove Alerts & Signals at BB-Squeeze',group='Settings: Signals',inline='Filter')
//stbs=input.bool(true,'Add Supertrend Buy/Sell',group='Settings: Signals',inline='filter')
adxsignalfilter= input(false, title='Remove Alerts & Signals at LOW ADX/SIDEWAYS',group='Settings: Signals',inline='Filter')
strengthtreshold=input(8, 'Table Alert Strength', group='Strategy: Table Strength',inline='table')
showtable=input.bool(true,'Show SSL Table', group='Strategy: Table Strength',inline='table')
showtable2=input.bool(true,'Show Strength Table', group='Strategy: Table Strength',inline='table')
//applystrength=input.bool(false,'Apply Strength to HMA', group='Strategy: Table Strength',inline='table')
show_ema200=input.bool(false,title='show Ema200 with ADX', group='Settings: Indicators')
showbbsqueeze = input(true, title='Show Bollinger Squeeze', group='Settings: Indicators')
showadxbg=input.bool(true,title='show Low ADX as Background',group='Candles')
showadxcandles=input.bool(true,title='show Low ADX Candles',group='Candles')
showbb=input.string('BB', title='Show Bollinger/Keltner Band',options=['--','BB','Keltner'],group='Settings: Indicators')
showmtfma=input.bool(false,title='Show MTF EMA', group='Settings: Indicators')
showqqedot = input.bool(true,title='Show QQE MOD Support', group='Settings: Indicators')
showbg = input.bool(true,title='QQE Signal Background', group='Settings: Indicators')
qqeline=input(title='QQE Line', defval=false, group='Settings: Indicators')
showpp = input(false, title='Show Pivot Points', group='Settings: Indicators')
showsr=input(false, title='Show Support Resistance', group='Settings: Indicators')
show_Baseline = input(title='Show SSL Baseline', defval=true, group='SSL')
show_SSL1 = input(title='Show SSL1 Support', defval=false, group='SSL')
showssl2=input(title='Show SSL2 Support', defval=false,group='SSL')
show_atr = input(title='Show ATR bands', defval=false, group='Settings: ATR')

//ATR
atrlen = input(14, 'ATR Period', group='Settings: ATR')
atrmult = input.float(1.5, 'ATR Multi', step=0.1, group='Settings: ATR')
smoothing = input.string(title='ATR Smoothing', defval='WMA', options=['RMA', 'SMA', 'EMA', 'WMA'], group='Settings: ATR')

ma_function(source, atrlen) =>
    if smoothing == 'RMA'
        ta.rma(source, atrlen)
    else
        if smoothing == 'SMA'
            ta.sma(source, atrlen)
        else
            if smoothing == 'EMA'
                ta.ema(source, atrlen)
            else
                ta.wma(source, atrlen)
atr_slen = ma_function(ta.tr(true), atrlen)
////ATR Up/Low Bands
upper_band = atr_slen * atrmult + close
lower_band = close - atr_slen * atrmult

////BASELINE / SSL1 / SSL2 / EXIT MOVING AVERAGE VALUES
maType = input.string(title='SSL1 / Baseline Type', defval='HMA', options=['ZLSMA','SMA', 'EMA', 'DEMA', 'TEMA', 'LSMA', 'WMA', 'MF', 'VAMA', 'TMA', 'HMA', 'JMA', 'Kijun v2', 'EDSMA', 'McGinley'], group='Settings: SSL')
baseline_len = input(title='SSL1 / Baseline Length', defval=55, group='Settings: SSL')

SSL2Type = input.string(title='SSL2 / Continuation Type', defval='JMA', options=['SMA', 'EMA', 'DEMA', 'TEMA', 'WMA', 'MF', 'VAMA', 'TMA', 'HMA', 'JMA', 'McGinley'], group='Settings: SSL')
len2 = input(title='SSL 2 Length', defval=5, group='Settings: SSL')
//
SSL3Type = input.string(title='EXIT Type', defval='HMA', options=['DEMA', 'TEMA', 'LSMA', 'VAMA', 'TMA', 'HMA', 'JMA', 'Kijun v2', 'McGinley', 'MF'], group='Settings: SSL')
len3 = input(title='EXIT Length', defval=15)
//src = input(title='Source', defval=close)

//
tema(src, len) =>
    ema1 = ta.ema(src, len)
    ema2 = ta.ema(ema1, len)
    ema3 = ta.ema(ema2, len)
    3 * ema1 - 3 * ema2 + ema3
kidiv = input.int(defval=1, maxval=4, title='Kijun MOD Divider', group='Settings: SSL')

jurik_phase = input(title='* Jurik (JMA) Only - Phase', defval=3, group='Settings: SSL')
jurik_power = input(title='* Jurik (JMA) Only - Power', defval=1, group='Settings: SSL')
volatility_lookback = input(10, title='* Volatility Adjusted (VAMA) Only - Volatility lookback length', group='Settings: SSL')
//MF
beta = input.float(0.8, minval=0, maxval=1, step=0.1, title='Modular Filter, General Filter Only - Beta', group='Settings: SSL')
feedback = input(false, title='Modular Filter Only - Feedback', group='Settings: SSL')
z = input.float(0.5, title='Modular Filter Only - Feedback Weighting', step=0.1, minval=0, maxval=1, group='Settings: SSL')
//EDSMA
ssfLength = input.int(title='EDSMA - Super Smoother Filter Length', minval=1, defval=20, group='Settings: SSL')
ssfPoles = input.int(title='EDSMA - Super Smoother Filter Poles', defval=2, options=[2, 3], group='Settings: SSL')

//----

//EDSMA
get2PoleSSF(src, length) =>
    PI = 2 * math.asin(1)
    arg = math.sqrt(2) * PI / length
    a1 = math.exp(-arg)
    b1 = 2 * a1 * math.cos(arg)
    c2 = b1
    c3 = -math.pow(a1, 2)
    c1 = 1 - c2 - c3

    ssf = 0.0
    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])
    ssf

get3PoleSSF(src, length) =>
    PI = 2 * math.asin(1)

    arg = PI / length
    a1 = math.exp(-arg)
    b1 = 2 * a1 * math.cos(1.738 * arg)
    c1 = math.pow(a1, 2)

    coef2 = b1 + c1
    coef3 = -(c1 + b1 * c1)
    coef4 = math.pow(c1, 2)
    coef1 = 1 - coef2 - coef3 - coef4

    ssf = 0.0
    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])
    ssf

ma(type, src, len) =>
    float result = 0
    if type == 'TMA'
        result := ta.sma(ta.sma(src, math.ceil(len / 2)), math.floor(len / 2) + 1)
        result
    if type == 'MF'
        ts = 0.
        b = 0.
        c = 0.
        os = 0.
        //----
        alpha = 2 / (len + 1)
        a = feedback ? z * src + (1 - z) * nz(ts[1], src) : src
        //----
        b := a > alpha * a + (1 - alpha) * nz(b[1], a) ? a : alpha * a + (1 - alpha) * nz(b[1], a)
        c := a < alpha * a + (1 - alpha) * nz(c[1], a) ? a : alpha * a + (1 - alpha) * nz(c[1], a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = beta * b + (1 - beta) * c
        lower = beta * c + (1 - beta) * b
        ts := os * upper + (1 - os) * lower
        result := ts
        result
    if type == 'LSMA'
        result := ta.linreg(src, len, 0)
        result
    if type == 'SMA'  // Simple
        result := ta.sma(src, len)
        result
    if type == 'EMA'  // Exponential
        result := ta.ema(src, len)
        result
    if type == 'DEMA'  // Double Exponential
        e = ta.ema(src, len)
        result := 2 * e - ta.ema(e, len)
        result
    if type == 'TEMA'  // Triple Exponential
        e = ta.ema(src, len)
        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)
        result
    if type == 'WMA'  // Weighted
        result := ta.wma(src, len)
        result
    if type == 'VAMA'  // Volatility Adjusted
        /// Copyright © 2019 to present, Joris Duyck (JD)
        mid = ta.ema(src, len)
        dev = src - mid
        vol_up = ta.highest(dev, volatility_lookback)
        vol_down = ta.lowest(dev, volatility_lookback)
        result := mid + math.avg(vol_up, vol_down)
        result
    if type == 'HMA'  // Hull
        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))
        result
    if type == 'JMA'  // Jurik
        /// Copyright © 2018 Alex Orekhov (everget)
        /// Copyright © 2017 Jurik Research and Consulting.
        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase / 100 + 1.5
        beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
        alpha = math.pow(beta, jurik_power)
        jma = 0.0
        e0 = 0.0
        e0 := (1 - alpha) * src + alpha * nz(e0[1])
        e1 = 0.0
        e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])
        e2 = 0.0
        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
        jma := e2 + nz(jma[1])
        result := jma
        result
    if type == 'Kijun v2'
        kijun = math.avg(ta.lowest(len), ta.highest(len))  //, (open + close)/2)
        conversionLine = math.avg(ta.lowest(len / kidiv), ta.highest(len / kidiv))
        delta = (kijun + conversionLine) / 2
        result := delta
        result
    if type == 'McGinley'
        mg = 0.0
        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src / mg[1], 4))
        result := mg
        result
    if type == 'EDSMA'

        zeros = src - nz(src[2])
        avgZeros = (zeros + zeros[1]) / 2

        // Ehlers Super Smoother Filter 
        ssf = ssfPoles == 2 ? get2PoleSSF(avgZeros, ssfLength) : get3PoleSSF(avgZeros, ssfLength)

        // Rescale filter in terms of Standard Deviations
        stdev = ta.stdev(ssf, len)
        scaledFilter = stdev != 0 ? ssf / stdev : 0

        alpha = 5 * math.abs(scaledFilter) / len

        edsma = 0.0
        edsma := alpha * src + (1 - alpha) * nz(edsma[1])
        result := edsma
        result
    if type == 'ZLSMA'
        lsma = ta.linreg(src, len, 0)
        lsma2 = ta.linreg(lsma, len, 0)
        eq= lsma-lsma2
        result := lsma+eq
        result
    result

///SSL 1 and SSL2
emaHigh = ma(maType, high, baseline_len)
emaLow = ma(maType, low, baseline_len)

maHigh = ma(SSL2Type, high, len2)
maLow = ma(SSL2Type, low, len2)

///EXIT
ExitHigh = ma(SSL3Type, high, len3)
ExitLow = ma(SSL3Type, low, len3)

///Keltner Baseline Channel
BBMC = ma(maType, close, baseline_len)
useTrueRange = input(true)
multy = input.float(0.2, step=0.05, title='Base Channel Multiplier', group='Settings: SSL')
Keltma = ma(maType, src, baseline_len)
range_1 = useTrueRange ? ta.tr : high - low
rangema = ta.ema(range_1, baseline_len)
upperk = Keltma + rangema * multy
lowerk = Keltma - rangema * multy

//Baseline Violation Candle
open_pos = open * 1
close_pos = close * 1
difference = math.abs(close_pos - open_pos)
atr_violation = difference > atr_slen
InRange = upper_band > BBMC and lower_band < BBMC
candlesize_violation = atr_violation and InRange
//plotshape(candlesize_violation, color=color.new(color.white, 0), size=size.tiny, style=shape.diamond, location=location.top, title='Candle Size > 1xATR')

//SSL1 VALUES
Hlv = int(na)
Hlv := close > emaHigh ? 1 : close < emaLow ? -1 : Hlv[1]
sslDown = Hlv < 0 ? emaHigh : emaLow

//SSL2 VALUES
Hlv2 = int(na)
Hlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]
sslDown2 = Hlv2 < 0 ? maHigh : maLow

//EXIT VALUES
Hlv3 = int(na)
Hlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]
sslExit = Hlv3 < 0 ? ExitHigh : ExitLow
base_cross_Long = ta.crossover(close, sslExit)
base_cross_Short = ta.crossover(sslExit, close)
codiff = base_cross_Long ? 1 : base_cross_Short ? -1 : na

//COLORS
show_color_bar = input(title='Color Bars', defval=true, group='Candles')
color_bar = close > upperk ?color.new( #00c3ff,0) : close < lowerk ? color.new(#ff0062,0) : color.new(color.gray,0)
color_ssl1 = close > sslDown ?color.new( #00c3ff,0) : close < sslDown ? color.new(#ff0062,0) :na
color_bar2=close > upperk ? color.new(#0000ff,0) : close < lowerk ? color.new(#ff0000,0) : color.new(color.gray,0)
//PLOTS
//plotarrow(codiff, colorup=color.new(#00c3ff, 20), colordown=color.new(#ff0062, 20), title='Exit Arrows', maxheight=20, offset=0)

//DownPlot = plot(show_SSL1 ? sslDown : na, title='SSL1', linewidth=3, color=color_ssl1)
//up_channel = plot(show_Baseline ? upperk : na, color=color_bar, title='Baseline Upper Channel')
//low_channel = plot(show_Baseline ? lowerk : na, color=color_bar, title='Baseline Lower Channel')
//fill(up_channel, low_channel, color=color_bar, transp=90)
//plotshape(sslsignals and ta.crossover(close,sslExit), title='SSL Buy', text='Buy', location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.new(#00c3ff, 50), textcolor=color.new(color.white, 0))
//plotshape(sslsignals and ta.crossover(sslExit,close), title='SSL Sell', text='Sell', location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.new(#ff0062, 50), textcolor=color.new(color.white, 0))

////SSL2 Continiuation from ATR
atr_crit = input.float(0.9, step=0.1, title='Continuation ATR Criteria', group='Settings: SSL')
upper_half = atr_slen * atr_crit + close
lower_half = close - atr_slen * atr_crit
buy_inatr = lower_half < sslDown2
sell_inatr = upper_half > sslDown2
sell_cont = close < BBMC and close < sslDown2
buy_cont = close > BBMC and close > sslDown2
sell_atr = sell_inatr and sell_cont
buy_atr = buy_inatr and buy_cont
atr_fill = buy_atr ? color.new(color.green,0) : sell_atr ? color.new(color.purple,0) : color.new(color.white,0)
//LongPlot = plot(showssl2?sslDown2:na, title='SSL2', linewidth=2, color=atr_fill, style=plot.style_circles)
//u = plot(show_atr ? upper_band : na, '+ATR', color=color.new(color.rgb(0, 255, 0, 50), 80),linewidth=2)
//l = plot(show_atr ? lower_band : na, '-ATR', color=color.new(color.rgb(255, 0, 0, 50), 80),linewidth=2)
//plot(BBMC,color=color.yellow,linewidth=4,title='BBMC')


///QQE MOD
RSI_Period = input(6, title='RSI Length',group='Settings:QQE-MOD')
SF = input(5, title='RSI Smoothing',group='Settings:QQE-MOD')
QQE = input.float(3, title='Fast QQE Factor',group='Settings:QQE-MOD',step=0.1)
ThreshHold = input(3, title='Thresh-hold',group='Settings:QQE-MOD')
qqsrc = input(close, title='RSI Source',group='Settings:QQE-MOD')
Wilders_Period = RSI_Period * 2 - 1
Rsi = ta.rsi(qqsrc, RSI_Period)
RsiMa = ta.ema(Rsi, SF)
AtrRsi = math.abs(RsiMa[1] - RsiMa)
MaAtrRsi = ta.ema(AtrRsi, Wilders_Period)
dar = ta.ema(MaAtrRsi, Wilders_Period) * QQE
longband = 0.0
shortband = 0.0
trend = 0
DeltaFastAtrRsi = dar
RSIndex = RsiMa
newshortband = RSIndex + DeltaFastAtrRsi
newlongband = RSIndex - DeltaFastAtrRsi
longband := RSIndex[1] > longband[1] and RSIndex > longband[1] ? math.max(longband[1], newlongband) : newlongband
shortband := RSIndex[1] < shortband[1] and RSIndex < shortband[1] ? math.min(shortband[1], newshortband) : newshortband
cross_1 = ta.cross(longband[1], RSIndex)
trend := ta.cross(RSIndex, shortband[1]) ? 1 : cross_1 ? -1 : nz(trend[1], 1)
FastAtrRsiTL = trend == 1 ? longband : shortband
////////////////////
bollength = input.int(50, minval=1, title='Bollinger Length',group='Settings:QQE-MOD')
qqmult = input.float(0.35, minval=0.001, maxval=5, step=0.1, title='BB Multiplier',group='Settings:QQE-MOD')
basis = ta.sma(FastAtrRsiTL - 50, bollength)
dev = qqmult * ta.stdev(FastAtrRsiTL - 50, bollength)
upper = basis + dev
lower = basis - dev
qqcolor_bar = RsiMa - 50 > upper ?color.new( #00c3ff,0) : RsiMa - 50 < lower ? color.new(#ff0062,0) : color.new(color.gray,0)
// Zero cross
QQEzlong = 0
QQEzlong := nz(QQEzlong[1])
QQEzshort = 0
QQEzshort := nz(QQEzshort[1])
QQEzlong := RSIndex >= 50 ? QQEzlong + 1 : 0
QQEzshort := RSIndex < 50 ? QQEzshort + 1 : 0
//Zero = hline(0, color=color.white, linestyle=hline.style_dotted, linewidth=1)
////////////////////////////////////////////////////////////////
RSI_Period2 = input(6, title='RSI Length',group='Settings:QQE-MOD')
SF2 = input(5, title='RSI Smoothing',group='Settings:QQE-MOD')
QQE2 = input.float(1.61, title='Fast QQE2 Factor',group='Settings:QQE-MOD',step=0.1)
ThreshHold2 = input(3, title='Threshold',group='Settings:QQE-MOD')
src2 = input(close, title='RSI Source',group='Settings:QQE-MOD')
Wilders_Period2 = RSI_Period2 * 2 - 1
Rsi2 = ta.rsi(src2, RSI_Period2)
RsiMa2 = ta.ema(Rsi2, SF2)
AtrRsi2 = math.abs(RsiMa2[1] - RsiMa2)
MaAtrRsi2 = ta.ema(AtrRsi2, Wilders_Period2)
dar2 = ta.ema(MaAtrRsi2, Wilders_Period2) * QQE2
longband2 = 0.0
shortband2 = 0.0
trend2 = 0
DeltaFastAtrRsi2 = dar2
RSIndex2 = RsiMa2
newshortband2 = RSIndex2 + DeltaFastAtrRsi2
newlongband2 = RSIndex2 - DeltaFastAtrRsi2
longband2 := RSIndex2[1] > longband2[1] and RSIndex2 > longband2[1] ? math.max(longband2[1], newlongband2) : newlongband2
shortband2 := RSIndex2[1] < shortband2[1] and RSIndex2 < shortband2[1] ? math.min(shortband2[1], newshortband2) : newshortband2
cross_2 = ta.cross(longband2[1], RSIndex2)
trend2 := ta.cross(RSIndex2, shortband2[1]) ? 1 : cross_2 ? -1 : nz(trend2[1], 1)
FastAtrRsi2TL = trend2 == 1 ? longband2 : shortband2
// Zero cross
QQE2zlong = 0
QQE2zlong := nz(QQE2zlong[1])
QQE2zshort = 0
QQE2zshort := nz(QQE2zshort[1])
QQE2zlong := RSIndex2 >= 50 ? QQE2zlong + 1 : 0
QQE2zshort := RSIndex2 < 50 ? QQE2zshort + 1 : 0
hcolor2 = RsiMa2 - 50 > ThreshHold2 ? color.new(#161b25,0): RsiMa2 - 50 < 0 - ThreshHold2 ? color.new(#161b25,0): color.new(#161b25,0)
//plot(ta.ema( close+(FastAtrRsi2TL-50)/10000,5), title='QQE Line', color=color.new(color.gray, 0), linewidth=2)
//plot(RsiMa2 - 50, color=hcolor2, title='Histo2', style=plot.style_columns, transp=50)
Greenbar1 = RsiMa2 - 50 > ThreshHold2
Greenbar2 = RsiMa - 50 > upper
Redbar1 = RsiMa2 - 50 < 0 - ThreshHold2
Redbar2 = RsiMa - 50 < lower
//plot(Greenbar1 and Greenbar2 == 1 ? RsiMa2 - 50 : na, title='QQE Up', style=plot.style_columns, color=color.new(#00c3ff, 0))
//plot(Redbar1 and Redbar2 == 1 ? RsiMa2 - 50 : na, title='QQE Down', style=plot.style_columns, color=color.new(#ff0062, 0))
//bgcolor(showbg and RsiMa2 - 50?hcolor2:na,title='QQE Bg GREY')
qqcolr=FastAtrRsiTL-50<RsiMa-50? color.new(#002734, 0):FastAtrRsiTL-50>RsiMa-50? color.new(#3a0016, 0): na
//bgcolor(showbg ?qqcolr:na,title='QQE Bg')

//--->plotshape(showqqedot?Greenbar1 and Greenbar2:na,color=color.new(#00c3ff, 20),title='QQE Up',style=shape.triangleup,size=size.auto,location=location.belowbar)
//--->plotshape(showqqedot?Redbar1 and Redbar2:na,color=color.new(#ff0062, 20),title='QQE Dn',style=shape.triangledown,size=size.auto,location=location.abovebar)


//plotarrow(codiff, colorup=color.new(#00c3ff, 20), colordown=color.new(#ff0062, 20), title='Exit Arrows', maxheight=20, offset=0)
//hcolor2 = RsiMa2 - 50 > ThreshHold2 ? color.silver : RsiMa2 - 50 < 0 - ThreshHold2 ? color.silver : na
qqecolor=Greenbar1 and Greenbar2 == 1 and RsiMa2 - 50? color.new(#00c3ff, 0):Redbar1 and Redbar2 == 1 and RsiMa2 - 50 ? color.new(#ff0062, 0):color.new(color.gray, 0)
//plot(qqeline?ta.ema( close+(FastAtrRsi2TL-50)/10000,5):na, title='QQE Line', color=qqecolor, linewidth=2)

qqxcolor=FastAtrRsiTL-50<RsiMa-50?color.new(color.green,0):FastAtrRsiTL-50>RsiMa-50?color.new(color.red,0):na
//p2=plot(FastAtrRsiTL-50,color=color.red,transp=0,linewidth=2)
//p1=plot(RsiMa-50,color=color.green,transp=0,linewidth=2)

waddah_sensitivity = input.int(150, title="Sensitivity", group='Indicators: Waddah Attar Explosion')
fastLength=input.int(20, title="FastEMA Length", group='Indicators: Waddah Attar Explosion')
slowLength=input.int(40, title="SlowEMA Length", group='Indicators: Waddah Attar Explosion')
channelLength=input.int(20, title="BB Channel Length", group='Indicators: Waddah Attar Explosion')
waeMult=input.float(2.0, title="BB Stdev Multiplier", group='Indicators: Waddah Attar Explosion')

calc_macd(source, fastLength, slowLength) =>
	fastMA = ta.ema(source, fastLength)
	slowMA = ta.ema(source, slowLength)
	fastMA - slowMA

calc_BBUpper(source, length, mult) => 
	basis = ta.sma(source, length)
	dev = mult * ta.stdev(source, length)
	basis + dev

calc_BBLower(source, length, mult) => 
	basis = ta.sma(source, length)
	dev = mult * ta.stdev(source, length)
	basis - dev

t1 = (calc_macd(close, fastLength, slowLength) - calc_macd(close[1], fastLength, slowLength))*waddah_sensitivity

e1 = (calc_BBUpper(close, channelLength, waeMult) - calc_BBLower(close, channelLength, waeMult))

trendUp = (t1 >= 0) ? t1 : 0
trendDown = (t1 < 0) ? (-1*t1) : 0
// Waddah Attar Explosion
waeBuy = trendUp > 0 and trendUp > e1
waeSell = trendDown > 0 and trendDown > e1
waecol=waeBuy?color.new(#00c3ff,0) :waeSell?color.new(#ff0062,0):color.new(color.gray,0)
//plot(trendUp, style=plot.style_columns, linewidth=1, color=(trendUp<trendUp[1]) ? color.lime : color.green, transp=45, title="UpTrend", display=display.none)
//plot(trendDown, style=plot.style_columns, linewidth=1, color=(trendDown<trendDown[1]) ? color.orange : color.red, transp=45, title="DownTrend", display=display.none)
//plot(e1, style=plot.style_line, linewidth=2, color=color.yellow, title="ExplosionLine", display=display.none)

///////////ADX
adxl=input(14, title='ADX/DMI length', group='Settings: ADX')
adxs=input(14, title='ADX/DMI smooth length', group='Settings: ADX')
[plus,minus,adx]=request.security(syminfo.tickerid,'',ta.dmi(adxl,adxs))
adxtreshold=input.int(20,'ADX Treshold', group='Settings: ADX')
em200=ta.ema(open,200)
adxem200color=adx>adxtreshold and plus>minus?color.new(color.lime, 0):adx>adxtreshold and plus<minus?color.new(color.maroon, 0):color.new(color.yellow, 0)
//plot(show_ema200 ? em200 : na, 'EMA200', color=adxem200color,linewidth=3,title='ADX Cross')
adxcross=ta.crossover(plus,minus)?color.new(color.blue, 0):ta.crossunder(plus,minus)?color.new(color.red, 0):na
//plotshape(ta.cross(plus,minus)?em200:na, color=adxcross, size=size.tiny,location=location.absolute, style=shape.diamond, title='ADX Cross')
///////////////////HULL+SUPRTREND
showhulltrend=input.bool(false,'Show HULL MTF',  group='Settings: Filters',inline='HULL')
showtrend=input.bool(false,'Show Supertrend', group='Settings: Filters',inline='Supertrend')
showstc=input.bool(true,title='SuperTrend Color/Hull Color',  group='Settings: Filters',inline='Supertrend')
mtf4 = input.timeframe(title="HULL TIME FRAME",  defval="",  group='Settings: Filters',inline='HULL')
stf4 = input.timeframe(title="SUPER TREND TIME FRAME",  defval="",  group='Settings: Filters',inline='Supertrend')
ma_length4 = input(110, title = "Hull TREND Length\n[Scalping:55,Floating S/R:100-300,]",  group='Settings: Filters',inline='HULL')

ma4 = request.security(syminfo.tickerid, mtf4,ta.hma(close, ma_length4),barmerge.gaps_on)
color4=open>ma4?color.new(#00ff00,0):open<ma4?color.new(#ff0000,0):color.new(color.gray,0)
//pl4 = plot(showhulltrend?ma4:na, title="MTF HULL TREND", color=color4, linewidth=4, offset=0)

[supertrend,direction]=request.security(syminfo.tickerid, stf4,ta.supertrend(input.float(3,title='Supertrend ATR Multiplier',step=0.1,  group='Settings: Filters',inline='Supertrend'),input.int(10,title='Supertrend Length',  group='Settings: Filters',inline='Supertrend')),barmerge.gaps_off)
supertrendup=direction<0?supertrend:na
supertrenddn=direction>0?supertrend:na
stc=supertrendup?color.new(#00c3ff,50):color.new(#ff0062,50)
trendcolor=showstc?stc:qqxcolor
//plot(showtrend?supertrendup:na,title='Supertrend Up',color=trendcolor,linewidth=4,style=plot.style_linebr)
//plot(showtrend?supertrenddn:na,title='Supertrend Down',color=trendcolor,linewidth=4,style=plot.style_linebr)

///////////////MACD///////////
[macd,signal,hist]=ta.macd(close,input.int(5,title='FAST MACD',group='Settings: MACD'),input.int(50,title='SLOW MACD',group='Settings: MACD'),input.int(30,title='Signal',group='Settings: MACD'))
//plotshape(ta.crossover(macd,signal)?close:na, title='MACD Crossover Buy', text='', location=location.belowbar, style=shape.xcross, size=size.tiny, color=color.new(#00FF00, 20), textcolor=color.new(color.white, 0))
//plotshape(ta.crossunder(macd,signal)?close:na, title='MACD Crossover Sell', text='', location=location.abovebar, style=shape.xcross, size=size.tiny, color=color.new(#ff0000, 0), textcolor=color.new(color.white, 0))
color_bars=showadxbg and adx<adxtreshold?color.new(color.purple,90):na
//bgcolor(adx<adxtreshold ? color_bars : na)
/////////////
/////////////////////////Bollinger Bands
matype=input.string('SMA',title='Bollinger MA type',options=['EMA','HMA','SMA'])
kLength = input(20, title='Keltner Length')
kN = input(2, title='Keltner Deviation')
bbLength = input(20, title='Bollinger Length')
bbN = input(2, title='Bollinger Deviation')
//--- Keltner
kma=matype=='EMA'?ta.ema(close, kLength):matype=='HMA'?ta.hma(close, kLength):ta.sma(close, kLength)
kUpper = kma + kN * ta.atr(kLength)
kLower = kma - kN * ta.atr(kLength)
//--- Bollinger
bma=matype=='EMA'?ta.ema(close, bbLength):matype=='HMA'?ta.hma(close, bbLength):ta.sma(close, bbLength)
bbUpper = bma + bbN * ta.stdev(close, bbLength)
bbLower = bma - bbN * ta.stdev(close, bbLength)
bbMiddle=matype=='EMA'?ta.ema(close, bbLength):matype=='HMA'?ta.hma(close, bbLength):ta.sma(close, bbLength)
//--- Bollinger Band Squeeze
squeeze = bbUpper <= kUpper and bbLower >= kLower
//--- Plots
//plot(bbUpper, title='Upper Band')
//plot(bbLower, title='Lower Band')
//--- Fill

//plot(showbb=='BB'?bbUpper:showbb=='Keltner'?kUpper:na, style=plot.style_linebr, color=color.new(color.purple, 0), title=' Upper Band')
//plot(showbb=='BB'?bbLower:showbb=='Keltner'?kLower:na, style=plot.style_linebr, color=color.new(color.purple, 0), title=' Lower Band')
//plot(showbb=='BB'?ta.sma(close,20):showbb=='Keltner'?ta.sma(close,20):na, style=plot.style_linebr, color=color.new(color.purple, 0), title=' Middle Band')
//a = plot(squeeze and showbbsqueeze? bbUpper : na, style=plot.style_linebr, color=bar_index ? na : color.new(color.white, 0), title='Squeezed Upper Band')
//b = plot(squeeze and showbbsqueeze? bbLower : na, style=plot.style_linebr, color=bar_index ? na : color.new(color.white, 0), title='Squeezed Lower Band')
//fill(a, b, color=color.new(color.purple, 90), title='Bollinger Squeezed Area')
//////////
///////////////Multi Time Frame EMA
mtf1 = input.timeframe(title="EMA MTF1",  defval="", group='Settings: EMA')
mtf2 = input.timeframe(title="EMA MTF2",  defval="", group='Settings: EMA')
ma_length1 = input(20, title = "EMA Period-1", group='Settings: EMA')
ma_length2 = input(50, title = "EMA Period-2", group='Settings: EMA')
ma1 = request.security(syminfo.tickerid, mtf1,  ta.ema(close, ma_length1),barmerge.gaps_on)
color1=open>ma1?color.new(#00FF00,60):open<ma1?color.new(#00FF00,60):color.new(color.gray,0)

//pl1 = plot(showmtfma?ma1:showbb=='BB'?bbMiddle:showbb=='Keltner'?bbMiddle:na, title="MTF EMA-1", color=showmtfma and ma1?color1:color.purple , linewidth=1, offset=0)

ma2 = request.security(syminfo.tickerid, mtf2,ta.ema(close, ma_length2),barmerge.gaps_on)
color2=open>ma2?color.new(#ff0000,60):open<ma2?color.new(#ff0000,60):color.new(color.gray,0)

//pl2 = plot(showmtfma?ma2:na, title="MTF EMA-2", color=color2, linewidth=1, offset=0)

//plotshape(ta.crossover(ma1,ma2)?close:na, title='EMA Crossover Buy', text='', location=location.belowbar, style=shape.xcross, size=size.tiny, color=color.new(#00FF00, 20), textcolor=color.new(color.white, 0))
//plotshape(ta.crossunder(ma1,ma2)?close:na, title='EMA Crossover Sell', text='', location=location.abovebar, style=shape.xcross, size=size.tiny, color=color.new(#ff0000, 50), textcolor=color.new(color.white, 0))
//////////////////
rsi()=>
    srce = close
    len = input.int(7, minval=1, title='RSI Length', group='RSI')
    srs = input.int(18, minval=1, title='RSI SMA Length', group='RSI')
    up = ta.rma(math.max(ta.change(srce), 0), len)
    down = ta.rma(-math.min(ta.change(srce), 0), len)
    rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - 100 / (1 + up / down)
    //mr = ta.ema(ta.ema(rsi, srs), srs)
    mr = ta.ema(ta.ema(ta.ema(rsi,srs), srs), srs)
    rsiupdn=rsi>mr?1:rsi<mr?-1:0
    [rsiupdn]

cci()=>
    ccilength = input.int(40, minval=1,title='CCI Length',group='CCI')
    ccisrc = input(hlc3, title="CCI Source",group='CCI')
    ccima = ta.sma(ccisrc, ccilength)
    cci = (ccisrc - ccima) / (0.015 * ta.dev(ccisrc, ccilength))
    ccibg= cci>100?1:cci<-100?-1:0
    [ccibg]
sto()=>
    OverBought = input(80,title='Stochastic OverBought Level',group='stochastic')
    OverSold = input(20,title='Stochastic OverBought Level',group='stochastic')
    k = ta.sma(ta.stoch(close, high, low, input.int(14, minval=1,title='Stochastic Length',group='stochastic')), input.int(3, minval=1,title='Stochastic Smooth Length K',group='stochastic'))
    d = ta.sma(k, input.int(3, minval=1,title='Stochastic Deviation Length D',group='stochastic'))
    co = ta.crossover(k,d)
    cu = ta.crossunder(k,d)
    sup=k > OverBought or cu and k > OverBought
    sdn=k < OverSold or co and  k < OverSold
    stobg=sup?1:sdn?-1:co?2:cu?-2:0
    [stobg]
start = input.float(title="PSAR Start",  step=0.001, defval=0.02, group="PSAR")
increment = input.float(title="PSAR Increment",  step=0.001, defval=0.02, group="PSAR")
maximum = input.float(title="PSAR Maximum", step=0.01, defval=0.2, group="PSAR")
psar = ta.sar(start, increment, maximum)
psarDir = psar < close ? 1 : -1
colorPSAR = psarDir == 1 ? color.new(#00c3ff,0) : color.new(#ff0062,0) //color_bar

exitsig = close > upperk and close > BBMC ?  color.new(#00c3ff,0) : close < lowerk and close < BBMC? color.new(#ff0062,0)  :color.new(color.gray,0)
qqedot=Greenbar1 and Greenbar2 and waeBuy? color.new(#00c3ff,0) : Redbar1 and Redbar2 and waeSell?color.new(#ff0062,0):color.new(color.gray,0)

adxcol=adx>20 and plus>minus?color.new(#00c3ff,0) :adx>20 and minus>plus?color.new(#ff0062,0):color.new(color.gray,0)
emacol=ta.crossover(ma1,ma2) or close>ma2 ? color.new(#00c3ff,0) :ta.crossunder(ma1,ma2) or close<ma2?color.new(#ff0062,0):color.new(color.gray,0)

psarn=psarDir == 1 ? 1 : -1 //PSAR VALUE
exitsign=close > upperk and close > 1 ?  1 : close < lowerk and close < BBMC? -1  : 0
qqedotn=Greenbar1 and Greenbar2 and waeBuy?1 : Redbar1 and Redbar2 and waeSell?-1:0
adxcoln=adx>20 and plus>minus?1 :adx>20 and minus>plus?-1:0
emacoln=ta.crossover(ma1,ma2) or close>ma2 ? 1 :ta.crossunder(ma1,ma2) or close<ma2?-1:0
waen=waeBuy?1:waeSell?-1:0
stval=direction<0 ?1:direction>0?-1:0
//SSL TABLE
[sto]=sto()
[rs]=rsi()
[cc]=cci()
stocol=sto>0 ? color.new(#00c3ff,0) :sto<0 ?color.new(#ff0062,0):color.new(color.gray,0)
rsicol=rs>0 ? color.new(#00c3ff,0) :rs<0 ?color.new(#ff0062,0):color.new(color.gray,0)
ccicol=cc>0 ? color.new(#00c3ff,0) :cc<0 ?color.new(#ff0062,0):color.new(color.gray,0)
sttrend=direction<0 ? color.new(#00c3ff,0) :direction>0?color.new(#ff0062,0):color.new(color.gray,0)
///////////Strategy Signals
qqeGreenBar = Greenbar1 and Greenbar2
qqeRedBar = Redbar1 and Redbar2
qqeBuy = qqeGreenBar and not qqeGreenBar[1]
qqeSell = qqeRedBar and not qqeRedBar[1]
p1 = plot(show_Baseline ? BBMC : na, color=color_bar, linewidth=4, title='MA Baseline')
//barcolor(show_color_bar ? color_bar :
         //show_color_bar and adx<adxtreshold and showadxcandles ?color.new(color.yellow,90):
         //na)
//lotshape(showqqedot?qqeGreenBar:na,color=color.new(#00ff00, 20),title='QQE Up',style=shape.triangleup,size=size.auto,location=location.belowbar)
//plotshape(showqqedot?qqeRedBar:na,color=color.new(#ff0000, 20),title='QQE Dn',style=shape.triangledown,size=size.auto,location=location.abovebar)
// SSL Hybrid
sslBuy = close > upperk and close > BBMC
sslSell = close < lowerk and close < BBMC
//STRATEGY
stratsslupsig=waeBuy and qqeBuy and sslBuy 
stratssldnsig=waeSell and qqeSell and sslSell 
//SSL HYBRID
sslup=ta.crossover(close,sslExit)
ssldn=ta.crossover(sslExit,close)
//SUPERTREND
strendup = direction<0 and ta.change(direction)  
strenddn = direction>0 and ta.change(direction) 
//SSL+SUPERTREND
sslupst=ta.crossover(close,sslExit) or strendup
ssldnst=ta.crossover(sslExit,close) or strenddn
//HMA DIRECTION
hmadirection=close>ma4?1:close<ma4?-1:0
signalup= strend=='NO-FILTER' and sslsignals=='SSL-HYBRID'?sslup:
          strend=='NO-FILTER' and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='NO-FILTER' and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          strend=='SUPERTREND' and direction<0 and sslsignals=='SSL-HYBRID'?sslup:
          strend=='SUPERTREND' and direction<0 and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='SUPERTREND' and direction<0 and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          strend=='HULL' and hmadirection>0 and sslsignals=='SSL-HYBRID'?sslup:
          strend=='HULL' and hmadirection>0 and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='HULL' and hmadirection>0 and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          na
signalup:=squeezesignalfilter and squeeze?na:signalup
signalup:=adxsignalfilter and adx<adxtreshold?na:signalup

signaldn= strend=='NO-FILTER' and sslsignals=='SSL-HYBRID'?ssldn:
          strend=='NO-FILTER' and sslsignals=='SSL+QQE+WAE' ? stratssldnsig:
          strend=='NO-FILTER' and sslsignals=='SSL-HYBRID+SuperTrend'?ssldnst:
          strend=='SUPERTREND' and direction>0 and sslsignals=='SSL-HYBRID'?ssldn:
          strend=='SUPERTREND' and direction>0 and sslsignals=='SSL+QQE+WAE'?stratssldnsig:
          strend=='SUPERTREND' and direction>0 and sslsignals=='SSL-HYBRID+SuperTrend'?ssldnst:
          strend=='HULL' and hmadirection<0 and sslsignals=='SSL-HYBRID'?sslup:
          strend=='HULL' and hmadirection<0 and sslsignals=='SSL+QQE+WAE'?stratsslupsig:
          strend=='HULL' and hmadirection<0 and sslsignals=='SSL-HYBRID+SuperTrend'?sslupst:
          na
signaldn:=squeezesignalfilter and squeeze?na:signaldn
signaldn:=adxsignalfilter and adx<adxtreshold?na:signaldn

plotshape(signalup, title='SSL Buy', text='Buy', location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.new(#00c3ff, 50), textcolor=color.new(color.white, 0))
plotshape(signaldn, title='SSL Sell', text='Sell', location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.new(#ff0062, 50), textcolor=color.new(color.white, 0))
//TABLE START
//psarn + exitsign + qqedotn +waen+ adxcoln + emacoln + sto + rs+ cc+stval
var ssltable = table.new(position.top_right, 2, 15, border_width = 3,bgcolor = color.new(color.black,0), border_color=color.new(#333333,0))

///TABLE STRENGTH
sslstrength=psarn + exitsign + qqedotn +waen+ adxcoln + emacoln + sto + rs+ cc+stval
strengthcol=sslstrength>strengthtreshold?color.new(#00c3ff,0) :sslstrength<-1*strengthtreshold ?color.new(#ff0062,0):color.new(color.gray,0)
var strengthtable = table.new(position.top_center, 2, 15, border_width = 3,bgcolor = color.new(color.black,0), border_color=color.new(#333333,0))

        


sideways=squeezesignalfilter and squeeze or adxsignalfilter and adx<adxtreshold
alertcondition(sslstrength>strengthtreshold or sslstrength<-1*strengthtreshold ,title='TABLE:Strength Alert',message='Table UP/DN Signal Strength')
//ALERTS
alertcondition(not sideways and ta.crossover(close, sslDown), title='SSL Hybrid:SSL Cross Alert', message='SSL1 has crossed.')
alertcondition(not sideways and ta.crossover(close, sslDown2), title='SSL Hybrid:SSL2 Cross Alert', message='SSL2 has crossed.')

alertcondition(not sideways and sell_atr, title='SSL Hybrid:Sell Continuation', message='Sell Continuation.')
alertcondition(not sideways and buy_atr, title='SSL Hybrid:Buy Continuation', message='Buy Continuation.')

alertcondition(not sideways and ta.crossover(close, sslExit), title='SSL Hybrid:Exit Sell', message='Exit Sell Alert.')
alertcondition(not sideways and ta.crossover(sslExit, close), title='SSL Hybrid:Exit Buy', message='Exit Buy Alert.')

alertcondition(not sideways and ta.crossover(close, upperk), title='SSL Hybrid:Baseline Buy Entry', message='Base Buy Alert.')
alertcondition(not sideways and ta.crossover(lowerk, close), title='SSL Hybrid:Baseline Sell Entry', message='Base Sell Alert.')

alertcondition(not sideways and ta.cross(ma1,ma2),title='Advanced:EMA20/50 Signal', message='Advanced:EMA20/50  Up/Dn  Signal')
alertcondition(not sideways and qqeBuy or not sideways and qqeSell,title='Advanced:QQE Crossover ', message ='Advanced: QQE Crossing Zero')

alertcondition(signalup or signaldn,title='FILTER:Buy/Sell Alert',message='FILTER:TREND FILTER Buy/Sell  Alert')
alertcondition(signalup ,title='FILTER:Buy Alert',message='FILTER:TREND FILTER- Buy Alert')
alertcondition(signaldn,title='FILTER:Sell Alert',message='FILTER:TREND FILTER- Sell Alert')

alertcondition(not sideways and ta.cross(close, sslExit), title='Advanced:SSL Buy Sell Alert', message='Advanced:SSL BUY / SELL / Alert.')
alertcondition(squeeze or adx<adxtreshold,title='Advanced ADX:Volatile Sideways /Exit trade', message='Advanced:Low ADX / Dont Trade /Exit Trade')
alertcondition(not sideways and ta.cross(open,ma4),title='Advanced: MTF/HMA Crossover', message='Advanced:MTF/HMA  Crossover Alert')

alertcondition(not sideways and ta.cross(ma1,ma2) or not sideways and ta.cross(open,ma4) or not sideways and ta.cross(close,sslExit) or not sideways and ta.change(direction),title='MIXED:SSL/Channel or EMA Cross or HMA Buy/sell or SuperTrend', message='MIXED Signal:\nSSL/Channel\n EMA Crossover\n HMA Entry/Exit \n SuperTrend Direction Changed')

///////////////////SUPPORT RESISTANCE//////////////////////////
prd = input.int(defval=10, title='Pivot Period', minval=4, maxval=30, group='S/R Settings')
ppsrc = input.string(defval='High/Low', title='Source', options=['High/Low', 'Close/Open'], group='S/R Settings')
maxnumpp = input.int(defval=20, title=' Maximum Number of Pivot', minval=5, maxval=100, group='S/R Settings')
ChannelW = input.int(defval=10, title='Maximum Channel Width %', minval=1, group='S/R Settings')
maxnumsr = input.int(defval=5, title=' Maximum Number of S/R', minval=1, maxval=10, group='S/R Settings')
min_strength = input.int(defval=2, title=' Minimum Strength', minval=1, maxval=10, group='S/R Settings')
labelloc = input.int(defval=20, title='Label Location', group='S/R Settings', tooltip='Positive numbers reference future bars, negative numbers reference histical bars')
linestyle = input.string(defval='Solid', title='Line Style', options=['Solid', 'Dotted', 'Dashed'], group='S/R Settings')
linewidth = input.int(defval=1, title='Line Width', minval=1, maxval=4, group='S/R Settings')
resistancecolor = input.color(defval=color.new(color.red,0), title='Resistance Color', group='S/R Settings')
supportcolor = input.color(defval=color.new(color.lime,0), title='Support Color', group='S/R Settings')

float src1 = ppsrc == 'High/Low' ? high : math.max(close, open)
float src12 = ppsrc == 'High/Low' ? low : math.min(close, open)
float ph = ta.pivothigh(src1, prd, prd)
float pl = ta.pivotlow(src12, prd, prd)

//plotshape(ph and showpp, text='H', style=shape.triangledown, color=color.new(color.red, 0), textcolor=color.new(color.white, 0), location=location.abovebar, offset=-prd,size=size.auto)
//plotshape(pl and showpp, text='L', style=shape.triangleup, color=color.new(color.lime, 0), textcolor=color.new(color.white, 0), location=location.belowbar, offset=-prd,size=size.auto)

Lstyle = linestyle == 'Dashed' ? line.style_dashed : linestyle == 'Solid' ? line.style_solid : line.style_dotted

//calculate maximum S/R channel zone width
prdhighest = ta.highest(300)
prdlowest = ta.lowest(300)
cwidth = (prdhighest - prdlowest) * ChannelW / 100

var pivotvals = array.new_float(0)

if ph or pl
    array.unshift(pivotvals, ph ? ph : pl)
    if array.size(pivotvals) > maxnumpp  // limit the array size
        array.pop(pivotvals)

get_sr_vals(ind) =>
    if showsr==true
        float lo = array.get(pivotvals, ind)
        float hi = lo
        int numpp = 0
        for y = 0 to array.size(pivotvals) - 1 by 1
            float cpp = array.get(pivotvals, y)
            float wdth = cpp <= lo ? hi - cpp : cpp - lo
            if wdth <= cwidth  // fits the max channel width?
                lo := cpp <= lo ? cpp : lo
                hi := cpp > lo ? cpp : hi
                numpp += 1
                numpp
        [hi, lo, numpp]

var sr_up_level = array.new_float(0)
var sr_dn_level = array.new_float(0)
sr_strength = array.new_float(0)

find_loc(strength) =>
    ret = array.size(sr_strength)
    for i = ret > 0 ? array.size(sr_strength) - 1 : na to 0 by 1
        if strength <= array.get(sr_strength, i)
            break
        ret := i
        ret
    ret

check_sr(hi, lo, strength) =>
    ret = true
    for i = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        //included?
        if array.get(sr_up_level, i) >= lo and array.get(sr_up_level, i) <= hi or array.get(sr_dn_level, i) >= lo and array.get(sr_dn_level, i) <= hi
            if strength >= array.get(sr_strength, i)
                array.remove(sr_strength, i)
                array.remove(sr_up_level, i)
                array.remove(sr_dn_level, i)
                ret
            else
                ret := false
                ret
            break
    ret

var sr_lines = array.new_line(11, na)
var sr_labels = array.new_label(11, na)

for x = 1 to 10 by 1
    rate = 100 * (label.get_y(array.get(sr_labels, x)) - close) / close
    label.set_text(array.get(sr_labels, x), text=str.tostring(label.get_y(array.get(sr_labels, x))) + '(' + str.tostring(rate, '#.##') + '%)')
    label.set_x(array.get(sr_labels, x), x=bar_index + labelloc)
    label.set_color(array.get(sr_labels, x), color=label.get_y(array.get(sr_labels, x)) >= close ? color.new(color.red,0) : color.new(color.lime,0))
    label.set_textcolor(array.get(sr_labels, x), textcolor=label.get_y(array.get(sr_labels, x)) >= close ? color.new(color.white,0) : color.new(color.black,0))
    label.set_style(array.get(sr_labels, x), style=label.get_y(array.get(sr_labels, x)) >= close ? label.style_label_down : label.style_label_up)
    line.set_color(array.get(sr_lines, x), color=line.get_y1(array.get(sr_lines, x)) >= close ? resistancecolor : supportcolor)

if ph or pl
    //because of new calculation, remove old S/R levels
    array.clear(sr_up_level)
    array.clear(sr_dn_level)
    array.clear(sr_strength)
    //find S/R zones
    for x = 0 to array.size(pivotvals) - 1 by 1
        [hi, lo, strength] = get_sr_vals(x)
        if check_sr(hi, lo, strength)
            loc = find_loc(strength)
            // if strength is in first maxnumsr sr then insert it to the arrays 
            if loc < maxnumsr and strength >= min_strength
                array.insert(sr_strength, loc, strength)
                array.insert(sr_up_level, loc, hi)
                array.insert(sr_dn_level, loc, lo)
                // keep size of the arrays = 5
                if array.size(sr_strength) > maxnumsr
                    array.pop(sr_strength)
                    array.pop(sr_up_level)
                    array.pop(sr_dn_level)

    for x = 1 to 10 by 1
        line.delete(array.get(sr_lines, x))
        label.delete(array.get(sr_labels, x))

    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        rate = 100 * (mid - close) / close
        array.set(sr_labels, x + 1, label.new(x=bar_index + labelloc, y=mid, text=str.tostring(mid) + '(' + str.tostring(rate, '#.##') + '%)', color=mid >= close ? color.new(color.red,0): color.new(color.lime,0), textcolor=mid >= close ? color.new(color.white,0) : color.new(color.black,0), style=mid >= close ? label.style_label_down : label.style_label_up))

        array.set(sr_lines, x + 1, line.new(x1=bar_index, y1=mid, x2=bar_index - 1, y2=mid, extend=extend.both, color=mid >= close ? resistancecolor : supportcolor, style=Lstyle, width=linewidth))

f_crossed_over() =>
    ret = false
    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        if close[1] <= mid and close > mid
            ret := true
            ret
    ret

f_crossed_under() =>
    ret = false
    for x = 0 to array.size(sr_up_level) > 0 ? array.size(sr_up_level) - 1 : na by 1
        float mid = math.round_to_mintick((array.get(sr_up_level, x) + array.get(sr_dn_level, x)) / 2)
        if close[1] >= mid and close < mid
            ret := true
            ret
    ret
alertcondition(f_crossed_over(), title='S/R:Resistance Broken', message='Resistance Broken')
alertcondition(f_crossed_under(), title='S/R:Support Broken', message='Support Broken')


devUp1 = input(1.28, title="Stdev above (1)")
devDn1 = input(1.28, title="Stdev below (1)")

devUp2 = input(2.01, title="Stdev above (2)")
devDn2 = input(2.01, title="Stdev below (2)")

devUp3 = input(2.51, title="Stdev above (3)")
devDn3 = input(2.51, title="Stdev below (3)")

devUp4 = input(3.09, title="Stdev above (4)")
devDn4 = input(3.09, title="Stdev below (4)")

devUp5 = input.float(4.01, title="Stdev above (5)")
devDn5 = input.float(4.01, title="Stdev below (5)")
showBcol = input.bool(true, title="Turn Barcolor ON/OFF?")
showDv2 = input.bool(true,  title="Show second group of bands?")
showDv3 = input.bool(true,  title="Show third group of bands?")
showDv4 = input.bool(false, title="Show fourth group of bands?")
showDv5 = input.bool(false,  title="Show fifth group of bands?")

showPrevVWAP = input.bool(false,  title="Show previous VWAP close")
ColorSrc=input(close)
price=ColorSrc
vwapstart = request.security(syminfo.tickerid, "D", time)

newSession = ta.change(vwapstart) ? 1 : 0

vwapsum := newSession ? hl2*volume : vwapsum[1]+hl2*volume
volumesum := newSession ? volume : volumesum[1]+volume
v2sum := newSession ? volume*hl2*hl2 : v2sum[1]+volume*hl2*hl2
myvwap = vwapsum/volumesum
vwapdev = math.sqrt(math.max(v2sum/volumesum - myvwap*myvwap, 0))

A=plot(myvwap,style=plot.style_circles, title="VWAP", color=color.black)
U1=plot(myvwap + devUp1 * vwapdev,style=plot.style_circles, title="VWAP Upper", color=color.gray)
D1=plot(myvwap - devDn1 * vwapdev, style=plot.style_circles, title="VWAP Lower", color=color.gray)

myvwapu1= myvwap + devUp1 * vwapdev
myvwapd1= myvwap - devDn1 * vwapdev

U2=plot(showDv2 ? myvwap + devUp2 * vwapdev : na, color=color.red, title="VWAP Upper (2)")
D2=plot(showDv2 ? myvwap - devDn2 * vwapdev : na, color=color.green, title="VWAP Lower (2)")

myvwapu2= myvwap + devUp2 * vwapdev
myvwapu3= myvwap + devUp3 * vwapdev
myvwapd2= myvwap - devDn2 * vwapdev
myvwapd3= myvwap - devDn3 * vwapdev

U3=plot(showDv3 ? myvwap + devUp3 * vwapdev : na, title="VWAP Upper (3)", color=color.red)
D3=plot(showDv3 ? myvwap - devDn3 * vwapdev : na, title="VWAP Lower (3)", color=color.green)

myvwapu4= myvwap + devDn4 * vwapdev
myvwapd4= myvwap - devDn4 * vwapdev

U4=plot(showDv4 ? myvwap + devUp4 * vwapdev : na, title="VWAP Upper (4)", color=color.red)
D4=plot(showDv4 ? myvwap - devDn4 * vwapdev : na, title="VWAP Lower (4)", color=color.green)

U5=plot(showDv5 ? myvwap + devUp5 * vwapdev : na, title="VWAP Upper (5)", color=color.red)
D5=plot(showDv5 ? myvwap - devDn5 * vwapdev : na, title="VWAP Lower (5)", color=color.green)

prevwap := newSession ? myvwap[1] : prevwap[1]

plot(showPrevVWAP ? prevwap : na, style=plot.style_circles, color=close > prevwap ? color.green : color.red)

ColorMiddleU = price > myvwap and price < myvwapu2 ? color.white:na
ColorMiddleD = price > myvwapd1 and price < myvwap ? color.black:na

ColorDv1d = price > myvwapd2 and price < myvwapd1 ? color.gray:na
ColorDv1u = price > myvwapu1 and price < myvwapu2 ? color.gray:na

ColorDv2d = price > myvwapd3 and price < myvwapd2 ? color.green:na
ColorDv2u = price > myvwapu2 and price < myvwapu3 ? color.maroon:na

ColorDv3d = price > myvwapd4 and price < myvwapd3 ? color.lime:na
ColorDv3u = price > myvwapu3 and price < myvwapu4 ? color.red:na

barcolor(showBcol?ColorMiddleD:na, title="BarColor vwap-1 Lower")
barcolor(showBcol?ColorMiddleU:na, title="BarColorColor vwap-1 upper")
barcolor(showBcol?ColorDv1d:na, title="BarColor 1-2 Lower")
barcolor(showBcol?ColorDv1u:na, title="BarColorColor 1-2 upper")
barcolor(showBcol?ColorDv2d:na, title="BarColor 2-3 Lower")
barcolor(showBcol?ColorDv2u:na, title="BarColorColor 2-3 upper")
barcolor(showBcol?ColorDv3d:na, title="BarColor 3-4 Lower")
barcolor(showBcol?ColorDv3u:na, title="BarColorColor 3-4 upper")

fill(U1, U2, color=color.red, transp=90, title="Over Bought Fill 1")
fill(D1, D2, color=color.green, transp=90, title="Over Sold Fill 1")
fill(U2, U3, color=color.red, transp=90, title="Over Bought Fill 2")
fill(D2, D3, color=color.green, transp=90, title="Over Sold Fill 2")
fill(U3, U4, color=color.red, transp=90, title="Over Bought Fill 3")
fill(D3, D4, color=color.green, transp=90, title="Over Sold Fill 3")
fill(U4, U5, color=color.red, transp=90, title="Over Bought Fill 4")
fill(D4, D5, color=color.green, transp=90, title="Over Sold Fill 4")
fill(A, U1, color=color.gray, transp=90, title="Middle Fill Up")
fill(A, D1, color=color.gray, transp=90, title="Middle Fill Down")
